// Code generated by counterfeiter. DO NOT EDIT.
package uaafakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/cli/api/uaa"
)

type FakeConfig struct {
	BinaryNameStub        func() string
	binaryNameMutex       sync.RWMutex
	binaryNameArgsForCall []struct{}
	binaryNameReturns     struct {
		result1 string
	}
	binaryNameReturnsOnCall map[int]struct {
		result1 string
	}
	BinaryVersionStub        func() string
	binaryVersionMutex       sync.RWMutex
	binaryVersionArgsForCall []struct{}
	binaryVersionReturns     struct {
		result1 string
	}
	binaryVersionReturnsOnCall map[int]struct {
		result1 string
	}
	DialTimeoutStub        func() time.Duration
	dialTimeoutMutex       sync.RWMutex
	dialTimeoutArgsForCall []struct{}
	dialTimeoutReturns     struct {
		result1 time.Duration
	}
	dialTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	UAAOAuthClientStub        func() string
	uAAOAuthClientMutex       sync.RWMutex
	uAAOAuthClientArgsForCall []struct{}
	uAAOAuthClientReturns     struct {
		result1 string
	}
	uAAOAuthClientReturnsOnCall map[int]struct {
		result1 string
	}
	UAAOAuthClientSecretStub        func() string
	uAAOAuthClientSecretMutex       sync.RWMutex
	uAAOAuthClientSecretArgsForCall []struct{}
	uAAOAuthClientSecretReturns     struct {
		result1 string
	}
	uAAOAuthClientSecretReturnsOnCall map[int]struct {
		result1 string
	}
	SetUAAEndpointStub        func(uaaEndpoint string)
	setUAAEndpointMutex       sync.RWMutex
	setUAAEndpointArgsForCall []struct {
		uaaEndpoint string
	}
	SkipSSLValidationStub        func() bool
	skipSSLValidationMutex       sync.RWMutex
	skipSSLValidationArgsForCall []struct{}
	skipSSLValidationReturns     struct {
		result1 bool
	}
	skipSSLValidationReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConfig) BinaryName() string {
	fake.binaryNameMutex.Lock()
	ret, specificReturn := fake.binaryNameReturnsOnCall[len(fake.binaryNameArgsForCall)]
	fake.binaryNameArgsForCall = append(fake.binaryNameArgsForCall, struct{}{})
	fake.recordInvocation("BinaryName", []interface{}{})
	fake.binaryNameMutex.Unlock()
	if fake.BinaryNameStub != nil {
		return fake.BinaryNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.binaryNameReturns.result1
}

func (fake *FakeConfig) BinaryNameCallCount() int {
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	return len(fake.binaryNameArgsForCall)
}

func (fake *FakeConfig) BinaryNameReturns(result1 string) {
	fake.BinaryNameStub = nil
	fake.binaryNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryNameReturnsOnCall(i int, result1 string) {
	fake.BinaryNameStub = nil
	if fake.binaryNameReturnsOnCall == nil {
		fake.binaryNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersion() string {
	fake.binaryVersionMutex.Lock()
	ret, specificReturn := fake.binaryVersionReturnsOnCall[len(fake.binaryVersionArgsForCall)]
	fake.binaryVersionArgsForCall = append(fake.binaryVersionArgsForCall, struct{}{})
	fake.recordInvocation("BinaryVersion", []interface{}{})
	fake.binaryVersionMutex.Unlock()
	if fake.BinaryVersionStub != nil {
		return fake.BinaryVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.binaryVersionReturns.result1
}

func (fake *FakeConfig) BinaryVersionCallCount() int {
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	return len(fake.binaryVersionArgsForCall)
}

func (fake *FakeConfig) BinaryVersionReturns(result1 string) {
	fake.BinaryVersionStub = nil
	fake.binaryVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersionReturnsOnCall(i int, result1 string) {
	fake.BinaryVersionStub = nil
	if fake.binaryVersionReturnsOnCall == nil {
		fake.binaryVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) DialTimeout() time.Duration {
	fake.dialTimeoutMutex.Lock()
	ret, specificReturn := fake.dialTimeoutReturnsOnCall[len(fake.dialTimeoutArgsForCall)]
	fake.dialTimeoutArgsForCall = append(fake.dialTimeoutArgsForCall, struct{}{})
	fake.recordInvocation("DialTimeout", []interface{}{})
	fake.dialTimeoutMutex.Unlock()
	if fake.DialTimeoutStub != nil {
		return fake.DialTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dialTimeoutReturns.result1
}

func (fake *FakeConfig) DialTimeoutCallCount() int {
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	return len(fake.dialTimeoutArgsForCall)
}

func (fake *FakeConfig) DialTimeoutReturns(result1 time.Duration) {
	fake.DialTimeoutStub = nil
	fake.dialTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) DialTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.DialTimeoutStub = nil
	if fake.dialTimeoutReturnsOnCall == nil {
		fake.dialTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.dialTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClient() string {
	fake.uAAOAuthClientMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientReturnsOnCall[len(fake.uAAOAuthClientArgsForCall)]
	fake.uAAOAuthClientArgsForCall = append(fake.uAAOAuthClientArgsForCall, struct{}{})
	fake.recordInvocation("UAAOAuthClient", []interface{}{})
	fake.uAAOAuthClientMutex.Unlock()
	if fake.UAAOAuthClientStub != nil {
		return fake.UAAOAuthClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uAAOAuthClientReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientCallCount() int {
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	return len(fake.uAAOAuthClientArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientReturns(result1 string) {
	fake.UAAOAuthClientStub = nil
	fake.uAAOAuthClientReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientReturnsOnCall(i int, result1 string) {
	fake.UAAOAuthClientStub = nil
	if fake.uAAOAuthClientReturnsOnCall == nil {
		fake.uAAOAuthClientReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecret() string {
	fake.uAAOAuthClientSecretMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientSecretReturnsOnCall[len(fake.uAAOAuthClientSecretArgsForCall)]
	fake.uAAOAuthClientSecretArgsForCall = append(fake.uAAOAuthClientSecretArgsForCall, struct{}{})
	fake.recordInvocation("UAAOAuthClientSecret", []interface{}{})
	fake.uAAOAuthClientSecretMutex.Unlock()
	if fake.UAAOAuthClientSecretStub != nil {
		return fake.UAAOAuthClientSecretStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uAAOAuthClientSecretReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientSecretCallCount() int {
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	return len(fake.uAAOAuthClientSecretArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientSecretReturns(result1 string) {
	fake.UAAOAuthClientSecretStub = nil
	fake.uAAOAuthClientSecretReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecretReturnsOnCall(i int, result1 string) {
	fake.UAAOAuthClientSecretStub = nil
	if fake.uAAOAuthClientSecretReturnsOnCall == nil {
		fake.uAAOAuthClientSecretReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientSecretReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) SetUAAEndpoint(uaaEndpoint string) {
	fake.setUAAEndpointMutex.Lock()
	fake.setUAAEndpointArgsForCall = append(fake.setUAAEndpointArgsForCall, struct {
		uaaEndpoint string
	}{uaaEndpoint})
	fake.recordInvocation("SetUAAEndpoint", []interface{}{uaaEndpoint})
	fake.setUAAEndpointMutex.Unlock()
	if fake.SetUAAEndpointStub != nil {
		fake.SetUAAEndpointStub(uaaEndpoint)
	}
}

func (fake *FakeConfig) SetUAAEndpointCallCount() int {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	return len(fake.setUAAEndpointArgsForCall)
}

func (fake *FakeConfig) SetUAAEndpointArgsForCall(i int) string {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	return fake.setUAAEndpointArgsForCall[i].uaaEndpoint
}

func (fake *FakeConfig) SkipSSLValidation() bool {
	fake.skipSSLValidationMutex.Lock()
	ret, specificReturn := fake.skipSSLValidationReturnsOnCall[len(fake.skipSSLValidationArgsForCall)]
	fake.skipSSLValidationArgsForCall = append(fake.skipSSLValidationArgsForCall, struct{}{})
	fake.recordInvocation("SkipSSLValidation", []interface{}{})
	fake.skipSSLValidationMutex.Unlock()
	if fake.SkipSSLValidationStub != nil {
		return fake.SkipSSLValidationStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.skipSSLValidationReturns.result1
}

func (fake *FakeConfig) SkipSSLValidationCallCount() int {
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	return len(fake.skipSSLValidationArgsForCall)
}

func (fake *FakeConfig) SkipSSLValidationReturns(result1 bool) {
	fake.SkipSSLValidationStub = nil
	fake.skipSSLValidationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) SkipSSLValidationReturnsOnCall(i int, result1 bool) {
	fake.SkipSSLValidationStub = nil
	if fake.skipSSLValidationReturnsOnCall == nil {
		fake.skipSSLValidationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.skipSSLValidationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ uaa.Config = new(FakeConfig)
