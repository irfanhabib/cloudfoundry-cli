// This file was generated by counterfeiter
package wrapperfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/cli/api/cloudcontroller/wrapper"
)

type FakeRequestLoggerOutput struct {
	DisplayTypeStub        func(name string, requestDate time.Time)
	displayTypeMutex       sync.RWMutex
	displayTypeArgsForCall []struct {
		name        string
		requestDate time.Time
	}
	DisplayHostStub        func(name string)
	displayHostMutex       sync.RWMutex
	displayHostArgsForCall []struct {
		name string
	}
	DisplayRequestStub        func(method string, uri string, httpProtocol string)
	displayRequestMutex       sync.RWMutex
	displayRequestArgsForCall []struct {
		method       string
		uri          string
		httpProtocol string
	}
	DisplayHeaderStub        func(name string, value string)
	displayHeaderMutex       sync.RWMutex
	displayHeaderArgsForCall []struct {
		name  string
		value string
	}
	DisplayBodyStub        func(body []byte)
	displayBodyMutex       sync.RWMutex
	displayBodyArgsForCall []struct {
		body []byte
	}
	DisplayResponseHeaderStub        func(httpProtocol string, status string)
	displayResponseHeaderMutex       sync.RWMutex
	displayResponseHeaderArgsForCall []struct {
		httpProtocol string
		status       string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRequestLoggerOutput) DisplayType(name string, requestDate time.Time) {
	fake.displayTypeMutex.Lock()
	fake.displayTypeArgsForCall = append(fake.displayTypeArgsForCall, struct {
		name        string
		requestDate time.Time
	}{name, requestDate})
	fake.recordInvocation("DisplayType", []interface{}{name, requestDate})
	fake.displayTypeMutex.Unlock()
	if fake.DisplayTypeStub != nil {
		fake.DisplayTypeStub(name, requestDate)
	}
}

func (fake *FakeRequestLoggerOutput) DisplayTypeCallCount() int {
	fake.displayTypeMutex.RLock()
	defer fake.displayTypeMutex.RUnlock()
	return len(fake.displayTypeArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayTypeArgsForCall(i int) (string, time.Time) {
	fake.displayTypeMutex.RLock()
	defer fake.displayTypeMutex.RUnlock()
	return fake.displayTypeArgsForCall[i].name, fake.displayTypeArgsForCall[i].requestDate
}

func (fake *FakeRequestLoggerOutput) DisplayHost(name string) {
	fake.displayHostMutex.Lock()
	fake.displayHostArgsForCall = append(fake.displayHostArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("DisplayHost", []interface{}{name})
	fake.displayHostMutex.Unlock()
	if fake.DisplayHostStub != nil {
		fake.DisplayHostStub(name)
	}
}

func (fake *FakeRequestLoggerOutput) DisplayHostCallCount() int {
	fake.displayHostMutex.RLock()
	defer fake.displayHostMutex.RUnlock()
	return len(fake.displayHostArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayHostArgsForCall(i int) string {
	fake.displayHostMutex.RLock()
	defer fake.displayHostMutex.RUnlock()
	return fake.displayHostArgsForCall[i].name
}

func (fake *FakeRequestLoggerOutput) DisplayRequest(method string, uri string, httpProtocol string) {
	fake.displayRequestMutex.Lock()
	fake.displayRequestArgsForCall = append(fake.displayRequestArgsForCall, struct {
		method       string
		uri          string
		httpProtocol string
	}{method, uri, httpProtocol})
	fake.recordInvocation("DisplayRequest", []interface{}{method, uri, httpProtocol})
	fake.displayRequestMutex.Unlock()
	if fake.DisplayRequestStub != nil {
		fake.DisplayRequestStub(method, uri, httpProtocol)
	}
}

func (fake *FakeRequestLoggerOutput) DisplayRequestCallCount() int {
	fake.displayRequestMutex.RLock()
	defer fake.displayRequestMutex.RUnlock()
	return len(fake.displayRequestArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayRequestArgsForCall(i int) (string, string, string) {
	fake.displayRequestMutex.RLock()
	defer fake.displayRequestMutex.RUnlock()
	return fake.displayRequestArgsForCall[i].method, fake.displayRequestArgsForCall[i].uri, fake.displayRequestArgsForCall[i].httpProtocol
}

func (fake *FakeRequestLoggerOutput) DisplayHeader(name string, value string) {
	fake.displayHeaderMutex.Lock()
	fake.displayHeaderArgsForCall = append(fake.displayHeaderArgsForCall, struct {
		name  string
		value string
	}{name, value})
	fake.recordInvocation("DisplayHeader", []interface{}{name, value})
	fake.displayHeaderMutex.Unlock()
	if fake.DisplayHeaderStub != nil {
		fake.DisplayHeaderStub(name, value)
	}
}

func (fake *FakeRequestLoggerOutput) DisplayHeaderCallCount() int {
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	return len(fake.displayHeaderArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayHeaderArgsForCall(i int) (string, string) {
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	return fake.displayHeaderArgsForCall[i].name, fake.displayHeaderArgsForCall[i].value
}

func (fake *FakeRequestLoggerOutput) DisplayBody(body []byte) {
	var bodyCopy []byte
	if body != nil {
		bodyCopy = make([]byte, len(body))
		copy(bodyCopy, body)
	}
	fake.displayBodyMutex.Lock()
	fake.displayBodyArgsForCall = append(fake.displayBodyArgsForCall, struct {
		body []byte
	}{bodyCopy})
	fake.recordInvocation("DisplayBody", []interface{}{bodyCopy})
	fake.displayBodyMutex.Unlock()
	if fake.DisplayBodyStub != nil {
		fake.DisplayBodyStub(body)
	}
}

func (fake *FakeRequestLoggerOutput) DisplayBodyCallCount() int {
	fake.displayBodyMutex.RLock()
	defer fake.displayBodyMutex.RUnlock()
	return len(fake.displayBodyArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayBodyArgsForCall(i int) []byte {
	fake.displayBodyMutex.RLock()
	defer fake.displayBodyMutex.RUnlock()
	return fake.displayBodyArgsForCall[i].body
}

func (fake *FakeRequestLoggerOutput) DisplayResponseHeader(httpProtocol string, status string) {
	fake.displayResponseHeaderMutex.Lock()
	fake.displayResponseHeaderArgsForCall = append(fake.displayResponseHeaderArgsForCall, struct {
		httpProtocol string
		status       string
	}{httpProtocol, status})
	fake.recordInvocation("DisplayResponseHeader", []interface{}{httpProtocol, status})
	fake.displayResponseHeaderMutex.Unlock()
	if fake.DisplayResponseHeaderStub != nil {
		fake.DisplayResponseHeaderStub(httpProtocol, status)
	}
}

func (fake *FakeRequestLoggerOutput) DisplayResponseHeaderCallCount() int {
	fake.displayResponseHeaderMutex.RLock()
	defer fake.displayResponseHeaderMutex.RUnlock()
	return len(fake.displayResponseHeaderArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayResponseHeaderArgsForCall(i int) (string, string) {
	fake.displayResponseHeaderMutex.RLock()
	defer fake.displayResponseHeaderMutex.RUnlock()
	return fake.displayResponseHeaderArgsForCall[i].httpProtocol, fake.displayResponseHeaderArgsForCall[i].status
}

func (fake *FakeRequestLoggerOutput) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.displayTypeMutex.RLock()
	defer fake.displayTypeMutex.RUnlock()
	fake.displayHostMutex.RLock()
	defer fake.displayHostMutex.RUnlock()
	fake.displayRequestMutex.RLock()
	defer fake.displayRequestMutex.RUnlock()
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	fake.displayBodyMutex.RLock()
	defer fake.displayBodyMutex.RUnlock()
	fake.displayResponseHeaderMutex.RLock()
	defer fake.displayResponseHeaderMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRequestLoggerOutput) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ wrapper.RequestLoggerOutput = new(FakeRequestLoggerOutput)
